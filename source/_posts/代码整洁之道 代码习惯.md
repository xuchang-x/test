---
title: 代码整洁之道 代码习惯
date: 2020-07-23 15:27:00
tags:
    - 代码整洁之道
    - clean code
    - 阅读笔记
description: 代码整洁之道前十章偏重个人写代码中的一些习惯问题
---
# 第一章 整洁代码
整洁代码的意义：

随着脏代码增加，团队生产力持续下降趋向于零。当生产力下降时，管理层就只有增加更多忍受到项目中，期望提升生产力。可是新人并不熟悉系统的设计，搞不清楚什么样的修改符合设计意图，什么样的修改违背设计意图。于是他们制造更多的混乱，生产力向零的那端不断下降。
![](生产力%20vs%20时间.jpg)

# 第二章 有意义的命名
- 核心：自解释性
    - 名副其实，避免抽象的abcd
    - 避免误导
        - 不要使用专有名词，入UNIX平台中的hp、aix、sco
        - 不要用有特殊意义的词汇，ex：不要用accountList指定账号列表，除非其本身是一个List(参照IDEA的自动命名，只有其本身是List时会加List后缀)
        - 拼写前后一致
        - 小写字母l<->常量1；大写字母O<->常量0
    - 做有意义的区分
        - 反例
            ```java
            getActiveAccount()
            getActiveAccounts()
            getActiveAccountInfo()
            ```
        - 减少无意义的词汇：ex：NameString->Name
    - 使用读的出来的名字：genymdhms(生成年月日时分秒)->genTimestamp
    - 使用可搜索的名称
        - 常量抽取：数字5 -> WORK_DAYS_PER_WEEK
    - 避免编码(多是C语言对名称长度有限制时留下的习惯)
        - 避免匈牙利语标记法，标记变量类型，用途的前后缀
        - 避免成员前缀 m_ 等
        - 接口和实现，接口不需要加前缀IXxFactory->xXFactory
    - 避免思维映射
        - 变量命名有直接意义，如循环中的i，如果是在更广的作用域中应给他一个具有实际意义的命名
    - 类名
        - 名次或名词短语
    - 方法名
        - 动词或动词短语
    - 使用正式的书面用语，代码里无需
    - 每个概念对应一个词
    - 别用双关
    - 使用解决方案领域名称
    - 使用院子所涉问题领域的名称
    - 添加有意义的语境
    - 不要添加没用的语境

# 第三章 函数
方法抽离、重命名
- 短小
    - 不要超过20行，每行不超过150个字符
    - 代码块和锁紧
- 只做一件事
- 每个函数一个抽象层级->自顶向下读代码：向下规则
    - 以返回HTML页面为例，每子自函数组装一个模块，最外层函数组装整个页面
- switch语句应该隐藏在factory模式中
    - 参考**开闭原则那几个**
- 使用描述性函数名
- 动词&关键词
    - assertEqual->assertExpectedEqualsActual(expected,actual)
- 函数参数
    - 最好没有参数
    - 最多不要超过三个参数
    - 超过三个参数其中一些参数需要封装成类
        - double x , double y -> Point center
- 无副作用
    - 函数中某些功能只有特定情况下才会用到，应该在函数名中有所体现
        - checkPassword -> checkPasswordAndInitializeSession
- 分隔指令与询问
    - `public boolean set(String attribute, String value)`
    - `if(set("username","unclebob"))`
    - 这一行中做了两件事情
    - 应该改成
        ```java
        if(attibuteExests("username")){
          setAttribute("username","unclebob");
        }
        ```
- 使用异常替代返回错误码
    ```java
    if(deletePage(page) == E_OK){
      if(registry.deleteReference(page.name) == E_OK){
        if(configKeys.deleteKey(page.name.makeKey()) == E_OK){
          logger.log("page deleted");
        }else{
          logger.log("configKey not deleted");
        }
      }else{
        logger.log("deleteReference from registry failed");
      }
    }else{
      logger.log("delete failed");
      return E_RROR;
    }
    ```
  ->
  ```java
    try{
      deletePage(page);
      registry.deleteReference(page.name);
      configKeys.deleteKey(page.name.makeKey());
    }catch(Exception e){
      logError(e);
    }
    ```
- 抽离try-catch代码块
    - try-catch处理异常作为单独的功能应该抽离成一个函数，主函数中不应有处理异常流程
- 别重复自己
- 结构化编程
    - 每个函数应该有一个入口一个出口
        - 大函数中不应该有break和continue，且只有一个return语句
        
# 第四章 注释
中心思想：注释用于补充解释无法自解释的的代码，如果代码能做到自解释是无需注释的。
- 注释并不能美化糟糕的代码
- 用代码来阐述
## 好注释
- 法律信息
- 提供信息的注释
    - 如解释某个抽象方法的返回值
- 对意图的解释
    - 解释某段代码(如for循环)的用途
- 阐释：把一些难懂的参数活返回值注释成可读的形式
- 警示：提示某些代码的重要性或需要特别注意的点
- TODO注释
    - 应该解释本次为什么无法实现，将来应该是怎样
    - 需要定期查看，删除不再需要的
- 放大
    - 方法某些看起来不合理地方的重要性
    - 类似警示，提示某些代码的重要作用
## 坏注释
- 喃喃自语
    - 不能解释具体作用，只有作者自己能懂的注释
- 多余的注释
    - 不能比代码提供更多的信息
    - 不如代码精确，可能提供错误的信息。如果读者更信赖注释，读了注释之后不再读代码，错误信息会被放大
- 误导性注释
- 循规式注释
    - 要求每个函数都有Javadoc一样的说明性注释是没必要的
- 日志式注释
    - 记录每次代码修改日志的注释是没必要的
- 废话注释
- 可怕的废话
    - 粘贴的注释，有误导性的废话
- 能用函数或变量时就别用注释
- 位置标记
    - 单纯为了标记代码中某个位置
    - ` // Actions //////////////////`
- 括号后面的注释
    - 嵌套层数深的长函数会有意义，但这种长函数应该拆分成更易读的小函数
- 归属与署名
    - 可以通过git看到
    - 随着代码被修改，署名越来越不准确
- 注释掉的代码
- HTML注释
- 非本地信息
    - 注释只描述离它最近的代码
        - 不要写系统级信息(如http使用8080端口)
- 信息过多
    - 不要添加无关的细节描述
- 不明显的联系
    - 注释里对象指代要清楚
- 函数头
    - 段函数不需要过多描述，为短函数选一个好名字即可
- 非公共代码中的Javadoc
    - Javadoc对公共API非常有用，但是不打算公开对代码没必要写这种注释

# 第五章 格式
代码的格式关乎代码可读性，从而影响后续的可维护性和扩展性
## 垂直格式
- 单个文件应在200行左右，最长不超过500行
- 向报纸学习
    - 名称简单一目了然，源文件最顶部给出高层次概念和算法，细节往下逐次展开
    - 报纸由许多篇文章组成，多数短小精悍；
- 概念间垂直方向上的区隔
    - 每组代码行展示一条完整的思路，这些代码组之间用空白行隔开
- 垂直方向上的靠近
    - 紧密相关的代码应该相互靠近
- 垂直距离
    目的是便于读者理解整个系统的目的，减少记忆代码碎片位置话费的时间和精力
    - 变量声明应尽可能靠近其使用位置，本地变量应该在函数的顶部出现
    - 实体变量应该在累的顶部声明
    - 相关函数应该放在一起，调用者尽可能放在被调用者上边(python无法实现)
    - 概念相关的代码应该放在一起，相关性越强距离越短
- 垂直顺序
    - 被调用函数应该放在执行调用的函数下面

## 横向格式
- 但行代码尽量小于80个字符，不要超过120个字符
- 水平方向上的区隔与靠近
    - 赋值操作左右添加空格
    - 函数名和左括号之间不加空格
    - 参数间一一隔开
    - 自己定义的水平分隔基本用不上，因为代码格式化时候就都消失了(比如idea里command + option + L)
- 水平对齐(已弃用)：变量声明时，多行之间等号左边上下对齐，等号右边上下对齐
- 缩进(idea command + option + L 即可)
    - 通过缩进模式，看代码行左侧就可以知道自己在什么范围中工作，从而快速跳过与当前情形无关的范围。
    - 即使是小的if、while循环或小函数也不要违反缩进规则写在一行
- 不要用空范围
    - while(blabla);
    - for(blabla);
- 团队规则
    - 团队规则 > 个人喜好
    
# 第六章 对象和数据结构
- 数据抽象
    - 隐藏实现并非只是在变量之间放上一个函数层，隐藏实现关乎抽象
    - 数据、对象的反对称性
        - 函数式编程便于在不改动既有数据结构的前提下增加新函数；面向对象编程便于在不改动既有函数的前提下添加新类。
        - 函数时编程难以添加新数据结构，因为比需求改所有函数；面向对象编程难以添加新函数，因为比需求改所有类。
- 得墨忒耳定律：模块不应了解他所操作对象的内部情形
    - 火车失事：一连串的调用，看起来就像是一列火车，应该避免。
        - `final String outputDir = ctxt.getOptions().getScratchir().getAbsolutePath();`
    - 混杂：一半是对象，一半是数据结构
        - 有执行函数，有公共变量，也有公共变量的getter和setter
    - 隐藏结构(核心)
        - 比如上述的outputDir最终应该是做什么的，最终是
        ```java
        String outputFile = outputDir + "/" + className.replace('.','/') + + "class";
        FileOutputStream fout = new FileOutputStream(outputFile);
        BufferedOutputStream bout = new BufferedOutputStream(fout);
        ```
        可以看到取出输出路径并不是一件完整的事情，可以将函数抽象成
        `BufferedOutputStream bout = ctxt.createScratchFileStream(classFileName);`从而隐藏内部结构，防止当前函数浏览他不需要知道的对象，导致违反得墨忒耳定律。
- 数据传输对象——DTO(Data Transfer Object)
    - 只有公共变量，没有函数的类，多用于与数据库或套接字传输消息场景。
    - Active Record
        - 特殊的DTO，拥有公共变量也拥有find或save这样的可浏览方法，一般是对数据库或其他数据源的直接翻译。
    - IMPORTANT: 不要向DTO中添加业务逻辑。

# 第七章 错误处理
- 错误处理很重要，但如果他扰乱了代码的逻辑，就是错误的做法
- 使用错误处理而非返回码
- 先写try-catch-finally语句
- 使用不可控异常
    - Java中的可控异常并非高稳定性软件所必须，同时它破坏了开闭原则，如果底层新抛出一种异常类型，则整个函数调用路径中都要增加向上一层抛出这个异常。
- 给出异常发生的环境说明
    - stack track
    - message
- 依调用者需要定义异常类
    - 封装第三方代码库
        - 减少在代码各个位置对第三方库抛出异常的捕获，从而减小耦合度，便于切换到其他库
- 定义常规流程
    - 底层封装各种特例对象进行返回，从而减少上层逻辑对异常的判断负担
- 别返回null值
    - 返回null值会大大增加其他代码的判断逻辑，可以返回空集合or空对象
- 别传递null值

# 第八章 边界
- 使用第三方代码
    - 第三方程序包&框架追求普适性，能在多个环境中工作
    - 使用者更像几种满足特定的需求
- 浏览和学习边界
    - **mark缺页**
- 学习性测试的好处不只是免费
    - 通过编写测试来使用、学习第三方API
    - 学习性测试是一种精确试验，帮助我们增进对API的理解，确保第三方程序包按我们想要的方式工作
    - 当第三方包发布了新版本，我们可以运行学习性测试来检测包的行为是否有所改变
- 使用尚不存在的代码
    - 当上下游代码尚未定义好，我们可以在自己的系统中先定义这个接口来使用，当接口定义完成后使用Adapter来桥接，这样也会使我们系统本身的代码更加清晰。
- 整洁的边界
    - 在边界上使用Adapter模式对接第三方包和我们的系统，在边界两侧推动内部一直的用法，当第三方代码发生改动时我们系统本身的修改点也会更少

# 第九章 单元测试
- TDD(测试驱动开发(Test-Driven Development))
    - 三定律
        - 在编写不能通过的单元测试前，不可编写生产代码
        - 只可编写刚好无法通过的单元测试，不能编译也算不过
        - 只可编写刚好足以通过当前失败测试的生产代码
    - 这样写代码会产生大量的测试。从而产生管理问题
- 保持整洁测试
    - 测试代码和生产代码一样重要，它不是二等公民，它需要被思考、被设计和被照料，它该像生产代码一样保持整洁。
    - 测试带来一切好处
        - 单元测试使代码可扩展、可维护、可复用。有了测试就不必担心对代码的修改，而没有测试每次修改都可能带来缺陷
- 整洁的测试
    - 可读性 明确、简洁、有足够的表达力
    - 面向特定领域的测试语言
    - 双重标准
    - 每个测试一个断言
        - 函数名和要测试的内容相同，符合given-when-then的约定
        - 可以用木板模式将given/when放到积累中，将then放到派生类中
    - FIRST
        - F:快速，快速运行
        - I:独立，相互独立
        - R:可重复，可在任何环境中通过
        - S:自足验证，测试应该有布尔值输出从而判定是否通过
        - T:及时，测试应及时编写

# 第十章 类
- 类的组织
    - 变量列表
        - 公共静态常量
        - 私有静态变量
        - 私有实体变量
    - 封装
- 类应该短小
    - 对于函数我们通过计算代码行数衡量大小，对于类我们计算权责(提供的函数功能)
    - 类的名称应该描述其权责
        - 大概25个单词
        - 无法精确命名就很容易导致类的权责过多
    - 单一权责原则
        - 类或模块应该有且只有一条加以修改的理由
        - 系统应由许多短小的类而不是少量大量的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。
    - 内聚
        - 类应该只有少量实体变量
        - 保持函数和参数列表短小的策略
    - 保持内聚性就会得到许多短小的类
        1. 一个拥有许多变量的大函数
        2. 拆分成单独的函数使用了共同的变量，需要分别声明
        3. 将这些变量提升为类的实体变量
        4. 类丧失了内聚性，越来越多的实体变量只为其中几个函数使用
        5. 拆分类
- 为了修改而组织
    - 对于多数系统，修改将一直持续。没出修改都让我们冒着系统其它部分不能如期望般工作的风险。在整洁的系统中，我们对类加以阻止以降低修改的风险。
    - 每个类中的代码都变得极为简单，理解类花费的时间几乎为零，函数对其他函数造成的破坏封建也变得几近于无。
    - 隔离修改