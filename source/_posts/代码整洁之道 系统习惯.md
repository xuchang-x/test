---
title: 代码整洁之道 代码习惯
date: 2020-09-20 15:35:00
tags:
    - 代码整洁之道
    - clean code
    - 阅读笔记
description: 代码整洁之道后三章中整个系统构建中的问题
---
# 第十一章 系统
- 如何建造一个城市
    - 有些人负责全局，其他人负责细节
    - 在系统层级上保持整洁
- 将系统的构造与使用分开
    - 软件系统应将其实过程中和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系。
    - 延迟初始化：运行时用到该对象才会去创建，打破了这个规则
        - 如果有大量零散的这种处理会导致缺乏模块组织性，通常也会有很多重复的代码。(持保留态度)
    - 分解main
        - 将所有构造过程在main模块中实现，其他模块使用过程中默认对象都已经正确构造和设置。(类似infoMap)
    - 工厂
    - 依赖注入(DI) & 控制反转(IoC)
- 扩容(增加新功能)
    - 软件系统与物理系统可以类比，他们的架构都可以递增式地增长，只要我们持续将关注面恰当地切分。
    - 横贯式关注面
        - 切面 (AOC)
- JAVA代理
    - JDK动态代理，仅能与接口协同工作
    - 字节码操作库，代理类，如CGLIB、ASM活Javaassist
- 纯AOP框架
    - 以Java代码的方式面向切面编程
- AspectJ 提供了比Spring AOP和Jboss AOP更全面的面向切面编程的方式，但是需要采用新的工具、学习新语言构造和使用方式。
- 测试驱动系统架构
    - 没必要先做大设计(Big Design Up Front , BDUF)，它阻碍改进，心理上会抵制丢弃现有设计，同时架构上的方案选择影响到后续的设计思路。
    - 最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言)对象实现。不同领域之间用最不具有侵害性的切面或类切面工具整合起来。这种架构能测试驱动，就像代码一样。
- 优化决策
    - 拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的只是做出优化的、时机刚好的决策。决策的复杂性也降低了。
- 明智使用添加了可论证价值的标准
    - 有了标准，就更易复用想法和组件、雇佣拥有相关经验的人才、封装好点子，以及将组建连接起来。不过，创立标准的过程有时却漫长到行业等不及的程度，有些标准没能与它要服务的采用者的真实需求相结合。
- 系统需要领域特定语言
    - 领域特定语言允许所有抽象层级和应用程序中的所有领域，从高级策略到底层细节，使用POJO来表达。

# 第十二章 迭进
- 通过迭进设计达到整洁目的，代码需要遵循的原则
    - 运行所有测试
    - 不可重复
    - 表达了程序员的意图
    - 尽可能减少类和方法的数量
- 简单设计规则1：运行所有测试
    - 设计必须制造出如预期一般工作的系统，这是首要因素
    - 遵循有关编写测试并持续运行的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标。编写测试引致更好的设计。
- 简单设计规则2～4：重构
    - 测试消除了对清理代码就会破坏代码的恐惧
    - 重构过程中可以应用有关优秀软件设计的一切只是。提升内举行，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，等等
    - 这也是应用简单设计后三条规则的地方：消除重复，保证表达力，尽可能减少类和方法的数量
- 不可重复
    - 重复的功能和代码不应该出现在设计良好的系统中，它代表着额外的工作
        - 如 int size()和 boolean isEmpty()两个方法可以分别实现也可以在isEmpty中使用size方法从而实现。(事实上java.util.ArrrayList也是这么做的)
- 表达力
    - 软件项目的主要成本在于长期维护，为了在修改时尽量降低出现缺陷的可能性，很有必要理解系统是做什么的。而作者把代码写的越清晰，其他人花在理解上的时间也就越少，从而减少缺陷，缩减维护成本。
- 尽可能减少的类和方法
    - 为了保持类和函数短小，我们可能会造出太多细小的类和方法，所以这条规则也主张函数和类的数量要少。
    - 我们的目标是在保持函数和类短小的同时，保持整个系统短小精悍。但要记住，这条规则是优先级最低的一条。

# 第十三章 并发编程
- 对象是过程的抽象，线程是调度的抽象
- 为什么要并发
    - 并发是一种解耦策略，他把我们做什么(目的)和何时做(时机)分开
    - 并发防御原则
        - 单一权责原则
            - 分离并发相关代码与其他代码
        - 推论：限制数据作用域
            - synchronized保护使用共享对象的临界区
        - 推论：使用数据复本
            - 避免共享数据，每个线程使用独立的副本
        - 推论：线程应尽可能的独立
            - 尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集
    - 相关Java库(书中还是java5版本)
        - 线程安全群集
            - java.util.concurrent
        - 同步方法之间的依赖
            - 避免使用一个共享对象的多个方法
                - 基于客户端的锁定：客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。
                - 基于服务端的锁定：在服务端内创建锁定服务的方法，调用所有方法，然后解锁。让客户端代码调用新方法。
                - 适配服务端：创建执行锁定的中间层。这是一种基于服务端的锁定的例子，但不修改原始服务端代码。
        - 保持同步区域微小
            - 锁会带来延迟和额外开销
        - 很难编写正确的关闭代码（死锁无法关闭）
            - 尽早考虑关闭问题，尽早令其工作正常。这回话费比你预期更多的时间。检视既有算法，因为这可能会比想象中难得多。
        - 测试线程代码
            - 编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果测试失败，跟踪错误，别因为后来测试通过了就忽略之前的失败。
            - 将伪失败看作可能的线程问题
                - 不要将系统错误归咎于偶发事件
            - 先使非线程代码可工作
            - 编写可插拔的线程代码
            - 编写可调整的线程代码
            - 运行处于多余处理器数量的线程
            - 在不同的平台上运行
            - 装置试错代码
                - 硬编码
                - 自动化
                    - Aspect-Oriented Framework、CGLib或ASM
       
# 第十四章 逐步改进
- 要编写整洁代码，必须先写肮脏代码，然后再清理它
- 渐进
    - 毁坏程序最好方法之一就是以改进之名大动其结构。有些程序永远不能从这种所谓"改进"中恢复过来。问题在于很难让程序以"改进"之前的方式工作。
    - 可以采用测试驱动开发规范，这种方式的核心原则之一是保证系统始终能运行。