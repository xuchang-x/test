---
title: 深入理解Java虚拟机 阅读笔记
date: 2020-07-15 14:36:00
tags:
    - java
    - 虚拟机
    - 阅读笔记
description: description
---
# 第一章 走进Java
- 优点特性
    1. 一次编写，到处运行
    2. 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界
    3. 热点代码检测和运行时便衣及优化，虽运行时间增加而获得更高的性能 TODO
- Java虚拟机 目前常用的HotSpot

# 第二章 自动内存管理机制
![运行时数据区](source/_posts/深入理解Java虚拟机 阅读笔记/运行时数据区.jpg)

1. 程序计数器
    
    当前线程所执行字节码的行号指示器
    
2. 虚拟机栈区

Java方法执行的内存模型，也就是java在方法中调用方法的过程中使用栈这种结构记录方法调用路径。

每个方法调用时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 TODO 动态链接是什么

3. 本地方法栈

和虚拟机栈类似，区别在于这个方法栈中放的是Native方法

4. 堆区

所有线程共享，用于存放对象实力

逃逸分析
全局变量赋值逃逸
方法返回值逃逸
实例引用发生逃逸
线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量.


    ``` java
   
    public class G {
    	public static B b;
    	
    	public void globalVariablePointerEscape(){//给全局变量赋值，发生逃逸
    		b=new B();
    	}
    	
    	public B methodPointerEscape(){//方法返回值，发生逃逸
    		return new B();
    	}
    	
    	public void instancePassPointerEscape(){
    		methodPointerEscape().printClassName(this);//实例引用发生逃逸
    	}
    	
    	
    }
     
    class B{
    	public void printClassName(G g){
    		System.out.println(g.getClass().getName());
    	}
    }
    ```
基于逃逸分析
同步消除
同步消除是java虚拟机提供的一种优化技术。通过逃逸分析，可以确定一个对象是否会被其他线程进行访问
如果对象没有出现线程逃逸，那该对象的读写就不会存在资源的竞争，不存在资源的竞争，则可以消除对该对象的同步锁。

```text
通过-XX:+EliminateLocks可以开启同步消除,进行测试执行的效率
```

栈上分配
我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。

```text
通过-XX:-DoEscapeAnalysis关闭逃逸分析
```     

标量替换
1.标量和聚合量
标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。

2.替换过程
通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。

```text
通过-XX:+EliminateAllocations可以开启标量替换， -XX:+PrintEliminateAllocations查看标量替换情况（Server VM 非Product版本支持）
```

5. 方法区(No-Heap)
用于存储一杯虚拟机加载的类信息、常量、静态变量、即使编译器变异后的代码等数据

6. 运行时常量池->方法去的一部分

7. 直接内存(Direct Memory)
并不是虚拟机运行时数据区一部分，也不是JVM中定义的内存区域
本季直接内存，不收到Java对内存大小限制。

---
对象创建
1.检查： 检查指令参数能否在常量池中定位到一个类负号引用，检查这个负号引用代表的呸是否已被加载、解析、初始化，若没有则先进行类加载。
2.内存分配： 类解灾后即可确定所需内存，内存分配
    - 内存规整："指针碰撞"->把指针向空闲方向挪动和对象大小相等的大小
        Serial,ParNew等带Compact过程的收集器
    - 空闲列表->维护一个列表，记录哪些内存块可用
        CMS这种基于Mark-Sweep的收集器
冲突处理
对象创建在虚拟机中是非常 频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来 分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理 ——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性;另一种是把内存分 配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内 存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)。哪个线程要分配内 存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。 虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。
3. 初始化 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实
       例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应 的零值。
       
4. <init>方法 把对象按照程序员的意愿进行初始化

---
对象内存布局
1. 对象头(MarkWord):对象自身的运行时数据， 如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等
![hotspot对象头](source/_posts/深入理解Java虚拟机 阅读笔记/hotspot对象头.jpg)
2. 实例数据
在程序代码中所定义的各种类型的字段内容
3. 对齐填充
起着占位符的作用。 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说， 就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍)， 因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
---
对象访问定位

句柄
![句柄访问对象](source/_posts/深入理解Java虚拟机 阅读笔记/句柄访问对象.jpg)
直接指针 速度更快，节省了一次指针定位的时间开销 (Hotspot 使用这种)
![直接指针访问](source/_posts/深入理解Java虚拟机 阅读笔记/直接指针访问.jpg)

堆内存溢出OutOfMemory
内存泄漏    内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
内存溢出    内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

栈内存溢出 StackOverFlow

操作系统分配给每个进程的内存是有限制的，譬如32位的Windows 限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内 存为2GB(操作系统限制)减去Xmx(最大堆容量)，再减去MaxPermSize(最大方法区容 量)，程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在 内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以 建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等

当前的很多主流框架，如Spring、Hibernate，在对类进行增强时， 都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class可以加载入内存。

Unsafe实例进行内存分配(Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回 实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能)。因为，虽然使用 DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申 请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方 法是unsafe.allocateMemory()。

# 第三章 垃圾收集器于内存分配策略

回收策略
1. 引用计数法：问题，循环引用的无法回收 a->b b->a

2. 可达性分析：GC Root做为起始点，找引用链
![引用链](source/_posts/深入理解Java虚拟机 阅读笔记/引用链.jpg)
    - 虚拟机栈(栈帧中的本地变量表)中引用的对象。
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用的对象。
    - 本地方法栈中JNI(即一般说的Native方法)引用的对象。
    
强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。
强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引 用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将 要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实 现软引用。
弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的 对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引 用。
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引 用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一 个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2之后，提供了PhantomReference类来实现虚引用。

要经历两次标记过程:如果对象在进行可达 性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或 者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行 它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做 的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情 况)，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统 崩溃。

---
方法区回收

hotspot中永久代->方法区
老年代+年轻代->堆区

很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规 范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集 的“性价比”一般比较低:在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以 回收70%~95%的空间，而永久代的垃圾收集效率远低于此。
永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。

判断常量废弃

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则 相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”:

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。 TODO
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 类的方法。

---
垃圾回收算法
1. 标记清除(要是能找到代码就更好了)
![](source/_posts/深入理解Java虚拟机 阅读笔记/标记清除.jpg)
它的主要不足有两个:
一个是效率问题，标记和清除两个过程的效率都不高;
另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾 收集动作。
2. 复制算法
![](source/_posts/深入理解Java虚拟机 阅读笔记/复制算法.jpg)
实现简单，运行高效。只是这种算法的代价是将内存缩小为了原 来的一半，未免太高了一点

HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，
也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，
只有10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，
我们没有办法保证每 次回收都只有不多于10%的对象存活，当Survivor空间不够用时，
需要依赖其他内存(这里 指老年代)进行分配担保(Handle Promotion)。

内存的分配担保也 一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时， 这些对象将直接通过分配担保机制进入老年代。

3. 标记整理
![](source/_posts/深入理解Java虚拟机 阅读笔记/标记整理.jpg)
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的 是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中 所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

4. 分代收集
当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算 法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

HotSpot算法实现
1. 枚举根节点
从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在 全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现 在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时 间。

在 HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的 时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也 会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知 这些信息了。

2. 安全点

在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问 题随之而来:可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一 条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很 高。


实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的 位置”记录了这些信息，这些位置称为安全点(Safepoint)，即程序执行时并非在所有地方都 能停顿下来开始GC，只有在到达安全点时才能暂停。

安全点的选定基 本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行 的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间 执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有 这些功能的指令才会产生Safepoint。
TODO没看懂